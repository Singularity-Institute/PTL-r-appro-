# Algorithme Knapsack Modifi√© pour R√©approvisionnement par Criticit√©
## Version S√©quenc√©e avec Priorit√©s et Optimisation par Cartons

---

## üéØ **Vue d'Ensemble de l'Approche**

Cette approche utilise un **algorithme Knapsack modifi√©** qui traite les mat√©riels par ordre de criticit√© d√©croissante, avec une strat√©gie de remplissage optimis√© des cartons selon des contraintes physiques sp√©cifiques par type d'article.

### **Principe Directeur**
```mermaid
graph TD
    INPUT[üìã Articles avec Criticit√©] --> SEQ[üîÑ Traitement S√©quenc√©]
    
    SEQ --> STEP1[1Ô∏è‚É£ Critiques A/B<br/>Cartons d√©di√©s obligatoires]
    SEQ --> STEP2[2Ô∏è‚É£ Urgents A<br/>Cartons d√©di√©s obligatoires]
    SEQ --> STEP3[3Ô∏è‚É£ Urgents B<br/>Compl√©ter cartons existants]
    SEQ --> STEP4[4Ô∏è‚É£ SAFE<br/>Compl√©ter espace restant]
    SEQ --> STEP5[5Ô∏è‚É£ Optimisation finale<br/>Compl√©ter par priorisation]
    
    STEP1 --> CARTONS[üì¶ Cartons Optimis√©s]
    STEP2 --> CARTONS
    STEP3 --> CARTONS
    STEP4 --> CARTONS
    STEP5 --> CARTONS
    
    style STEP1 fill:#ffcdd2
    style STEP2 fill:#ffab91
    style STEP3 fill:#fff3e0
    style STEP4 fill:#c8e6c9
    style STEP5 fill:#e1f5fe
```

---

## üìä **Classification des Articles et Contraintes Cartons**

### **Cat√©gories de Criticit√©**
```mermaid
graph TB
    subgraph "Hi√©rarchie de Criticit√©"
        CRIT_A[üî¥ CRITIQUES A<br/>Arr√™t service imm√©diat]
        CRIT_B[üî¥ CRITIQUES B<br/>Arr√™t service < 24h]
        URG_A[üü† URGENTS A<br/>Impact service < 48h]
        URG_B[üü° URGENTS B<br/>Impact service < 7j]
        SAFE[üü¢ SAFE<br/>Stock pr√©ventif]
    end
    
    subgraph "Contraintes Cartons"
        CONSTRAINT[üì¶ Contraintes par Type<br/>Type 1: max X articles<br/>Type 2: max Y articles<br/>Type 3: max Z articles<br/>Poids max: 30kg<br/>Volume max: 50L]
    end
    
    CRIT_A --> CONSTRAINT
    CRIT_B --> CONSTRAINT
    URG_A --> CONSTRAINT
    URG_B --> CONSTRAINT
    SAFE --> CONSTRAINT
    
    style CRIT_A fill:#ffcdd2
    style CRIT_B fill:#ffcdd2
    style URG_A fill:#ffab91
    style URG_B fill:#fff3e0
    style SAFE fill:#c8e6c9
```

### **Contraintes Physiques par Type d'Article**
```json
{
  "contraintes_carton": {
    "type_1_centrales": {"max_articles": 10, "poids_unitaire": 2.5, "volume_unitaire": 0.5},
    "type_2_claviers": {"max_articles": 15, "poids_unitaire": 0.8, "volume_unitaire": 0.3},
    "type_3_detecteurs": {"max_articles": 50, "poids_unitaire": 0.2, "volume_unitaire": 0.1},
    "type_4_cameras": {"max_articles": 8, "poids_unitaire": 3.0, "volume_unitaire": 0.8},
    "type_5_cables": {"max_articles": 100, "poids_unitaire": 0.1, "volume_unitaire": 0.05}
  },
  "limites_globales": {
    "poids_max_kg": 30.0,
    "volume_max_litres": 50.0
  }
}
```

---

## üîÑ **Algorithme Knapsack S√©quenc√© Modifi√©**

### **Algorithme Principal**

```mermaid
flowchart TD
    START[üöÄ D√©but Algorithme] --> COLLECT[üìä Collecte Articles<br/>avec Criticit√© et Besoins]
    
    COLLECT --> SORT_CRIT[üîÑ Tri par Criticit√©<br/>CRIT_A ‚Üí CRIT_B ‚Üí URG_A ‚Üí URG_B ‚Üí SAFE]
    
    SORT_CRIT --> PHASE1[üì¶ PHASE 1: Critiques A/B<br/>Cr√©er cartons d√©di√©s]
    
    PHASE1 --> PHASE2[üì¶ PHASE 2: Urgents A<br/>Cr√©er cartons d√©di√©s]
    
    PHASE2 --> PHASE3[üì¶ PHASE 3: Urgents B<br/>Compl√©ter cartons existants]
    
    PHASE3 --> CHECK_ONLY_URG_B{ü§î Seulement<br/>Urgents B ?}
    
    CHECK_ONLY_URG_B -->|OUI| COMPLETE_URG_B[üì¶ Compl√©ter cartons<br/>par articles prioritaires]
    CHECK_ONLY_URG_B -->|NON| PHASE4[üì¶ PHASE 4: Articles SAFE<br/>Compl√©ter espace restant]
    
    COMPLETE_URG_B --> PHASE5[üì¶ PHASE 5: Optimisation finale]
    PHASE4 --> PHASE5
    
    PHASE5 --> VALIDATE[‚úÖ Validation Contraintes<br/>Poids/Volume/Nombre]
    
    VALIDATE --> OUTPUT[üìã Cartons Optimis√©s<br/>avec Composition D√©taill√©e]
    
    style PHASE1 fill:#ffcdd2
    style PHASE2 fill:#ffab91
    style PHASE3 fill:#fff3e0
    style PHASE4 fill:#c8e6c9
    style PHASE5 fill:#e1f5fe
```

### **D√©tail de l'Algorithme**

```
ALGORITHME KnapsackModifieParCriticite(liste_articles)
D√âBUT
    cartons ‚Üê []
    articles_trait√©s ‚Üê []
    
    // === PHASE 1: CRITIQUES A/B - TRAITEMENT OBLIGATOIRE ===
    articles_critiques ‚Üê FiltrerParCriticite(liste_articles, ["CRIT_A", "CRIT_B"])
    
    POUR CHAQUE article DANS articles_critiques FAIRE
        cartons_necessaires ‚Üê CalculerCartonsNecessaires(article)
        POUR i ‚Üê 1 A cartons_necessaires FAIRE
            carton ‚Üê NouveauCarton()
            RemplirCartonMaximal(carton, article)
            cartons.ajouter(carton)
        FIN POUR
        articles_trait√©s.ajouter(article)
    FIN POUR
    
    // === PHASE 2: URGENTS A - TRAITEMENT OBLIGATOIRE ===
    articles_urgents_a ‚Üê FiltrerParCriticite(liste_articles, ["URG_A"])
    SOUSTRACTION(articles_urgents_a, articles_trait√©s)
    
    POUR CHAQUE article DANS articles_urgents_a FAIRE
        cartons_necessaires ‚Üê CalculerCartonsNecessaires(article)
        POUR i ‚Üê 1 A cartons_necessaires FAIRE
            carton ‚Üê NouveauCarton()
            RemplirCartonMaximal(carton, article)
            cartons.ajouter(carton)
        FIN POUR
        articles_trait√©s.ajouter(article)
    FIN POUR
    
    // === PHASE 3: URGENTS B - COMPL√âTER CARTONS EXISTANTS ===
    articles_urgents_b ‚Üê FiltrerParCriticite(liste_articles, ["URG_B"])
    SOUSTRACTION(articles_urgents_b, articles_trait√©s)
    
    SI articles_urgents_b.non_vide ALORS
        // Essayer de compl√©ter les cartons existants
        POUR CHAQUE article DANS articles_urgents_b FAIRE
            carton_compatible ‚Üê TrouverCartonCompatible(cartons, article)
            SI carton_compatible ‚â† null ALORS
                AjouterAuCarton(carton_compatible, article)
                articles_trait√©s.ajouter(article)
            FIN SI
        FIN POUR
        
        // Cr√©er nouveaux cartons pour articles restants si n√©cessaire
        articles_urgents_b_restants ‚Üê SOUSTRACTION(articles_urgents_b, articles_trait√©s)
        SI articles_urgents_b_restants.non_vide ALORS
            POUR CHAQUE article DANS articles_urgents_b_restants FAIRE
                carton ‚Üê TrouverOuCreerCarton(cartons, article)
                AjouterAuCarton(carton, article)
                articles_trait√©s.ajouter(article)
            FIN POUR
        FIN SI
    FIN SI
    
    // === PHASE 4: ARTICLES SAFE - REMPLISSAGE OPPORTUNISTE ===
    articles_safe ‚Üê FiltrerParCriticite(liste_articles, ["SAFE"])
    SOUSTRACTION(articles_safe, articles_trait√©s)
    
    POUR CHAQUE carton DANS cartons FAIRE
        TANT QUE carton.a_espace_disponible FAIRE
            article_optimal ‚Üê ChoisirMeilleurArticle(articles_safe, carton)
            SI article_optimal ‚â† null ALORS
                AjouterAuCarton(carton, article_optimal)
                articles_safe.retirer(article_optimal)
            SINON
                SORTIR // Plus d'articles compatibles
            FIN SI
        FIN TANT QUE
    FIN POUR
    
    // === PHASE 5: OPTIMISATION FINALE ===
    // Cas sp√©cial: Si seuls des Urgents B, compl√©ter par articles prioritaires
    SI SeulementUrgentsB(liste_articles) ALORS
        articles_complementaires ‚Üê IdentifierArticlesComplementaires()
        POUR CHAQUE carton DANS cartons FAIRE
            CompleterParPriorisation(carton, articles_complementaires)
        FIN POUR
    FIN SI
    
    // Validation finale
    POUR CHAQUE carton DANS cartons FAIRE
        ValiderContraintes(carton)
    FIN POUR
    
    RETOURNER cartons
FIN
```

---

## üì¶ **Gestion des Cartons et Contraintes**

### **Structure d'un Carton**

```mermaid
classDiagram
    class Carton {
        +id: String
        +articles: Map<Type, Integer>
        +contraintes_type: Map<Type, Integer>
        
        +peutAjouter(article, quantite): Boolean
        +ajouterArticle(article, quantite): void
        +calculerEspaceRestant(): EspaceDisponible
        +obtenirTauxRemplissage(): Float
        +validerContraintes(): Boolean
    }
    
    class EspaceDisponible {
        +capacite_par_type: Map<Type, Integer>
        
        +peutAccueillir(article, quantite): Boolean
    }
    
    Carton --> EspaceDisponible
```

### **Algorithme de Remplissage Optimal**

```mermaid
sequenceDiagram
    participant Algo as Algorithme
    participant Carton as Carton
    participant Constraint as Validateur Contraintes
    participant Article as Article
    
    Note over Algo,Article: Remplissage d'un Carton
    
    Algo->>Carton: calculerEspaceRestant()
    Carton->>Algo: EspaceDisponible
    
    Algo->>Article: obtenirCaracteristiques()
    Article->>Algo: {type, quantite}
    
    Algo->>Constraint: peutAjouter(carton, article, quantite)
    Constraint->>Constraint: V√©rifier contraintes type seulement
    Constraint->>Algo: Boolean r√©sultat
    
    alt Si compatible
        Algo->>Carton: ajouterArticle(article, quantite)
        Carton->>Carton: Mettre √† jour compteurs types
        Carton->>Algo: Confirmation ajout
    else Si incompatible
        Algo->>Algo: Chercher carton alternatif
        alt Si aucun carton compatible
            Algo->>Carton: NouveauCarton()
            Algo->>Carton: ajouterArticle(article, quantite)
        end
    end
```

---

## üéØ **Syst√®me de Priorisation pour Compl√©tion**

### **Calcul du Score de Priorit√©**

```mermaid
flowchart TD
    ARTICLE[üì¶ Article Candidat] --> STOCK_RATIO[üìä Ratio Stock Actuel<br/>vs Stock Optimal]
    ARTICLE --> USAGE_TREND[üìà Tendance Usage<br/>R√©cent]
    ARTICLE --> VALUE_DENSITY[üíé Densit√© Valeur<br/>‚Ç¨/kg ou ‚Ç¨/volume]
    ARTICLE --> CRITICALITY[‚ö†Ô∏è Criticit√© M√©tier<br/>Impact si rupture]
    
    STOCK_RATIO --> SCORE_CALC[üßÆ Calcul Score<br/>Priorit√©]
    USAGE_TREND --> SCORE_CALC
    VALUE_DENSITY --> SCORE_CALC
    CRITICALITY --> SCORE_CALC
    
    SCORE_CALC --> DECISION{Score ><br/>Seuil?}
    
    DECISION -->|OUI| INCLUDE[‚úÖ Inclure dans<br/>Compl√©tion]
    DECISION -->|NON| EXCLUDE[‚ùå Exclure de la<br/>S√©lection]
    
    style SCORE_CALC fill:#fff3e0
    style INCLUDE fill:#c8e6c9
    style EXCLUDE fill:#ffcdd2
```

### **Formule de Priorisation**

```
Score_Priorit√© = Œ± √ó Ratio_Stock + Œ≤ √ó Tendance_Usage + Œ≥ √ó Densit√©_Valeur + Œ¥ √ó Criticit√©_M√©tier

O√π:
- Ratio_Stock = (Stock_Min + Stock_Max)/2 - Stock_Actuel) / Stock_Max
- Tendance_Usage = Usage_R√©cent / Usage_Moyen_Historique  
- Densit√©_Valeur = Valeur_Unitaire / Quantit√©_Unitaire
- Criticit√©_M√©tier ‚àà {0.2, 0.5, 0.8, 1.0} selon impact m√©tier

Coefficients sugg√©r√©s: Œ±=0.4, Œ≤=0.3, Œ≥=0.2, Œ¥=0.1
```

---

## üîÑ **Diagramme de S√©quence Complet**

```mermaid
sequenceDiagram
    participant User as Utilisateur
    participant Engine as Moteur Knapsack
    participant Sorter as Trieur Criticit√©
    participant Packer as Optimiseur Cartons
    participant Validator as Validateur
    participant Output as G√©n√©rateur Sortie
    
    Note over User,Output: Processus Knapsack Modifi√© Complet
    
    User->>Engine: Lancer algorithme(liste_articles)
    Engine->>Sorter: Trier par criticit√©
    Sorter->>Engine: Articles tri√©s par niveau
    
    Note over Engine,Packer: Phase 1 - Critiques A/B + Urgents A
    Engine->>Packer: Traiter articles prioritaires
    Packer->>Packer: Cr√©er cartons d√©di√©s obligatoires
    Packer->>Engine: Cartons prioritaires cr√©√©s
    
    Note over Engine,Packer: Phase 2 - Urgents B + SAFE
    Engine->>Packer: Traiter articles secondaires
    Packer->>Packer: Compl√©ter cartons existants
    alt Si cartons pleins
        Packer->>Packer: Cr√©er nouveaux cartons
    end
    Packer->>Engine: Articles secondaires trait√©s
    
    Note over Engine,Packer: Phase 3 - Optimisation
    Engine->>Engine: Cas sp√©cial Urgents B + SAFE seuls?
    alt Si uniquement Urgents B + SAFE
        Engine->>Packer: Compl√©ter par priorisation
        Packer->>Packer: Ajouter articles prioritaires
    end
    
    Note over Engine,Output: Validation et Sortie
    Engine->>Validator: Valider tous cartons
    Validator->>Validator: V√©rifier contraintes
    Validator->>Engine: Validation OK
    
    Engine->>Output: G√©n√©rer rapport d√©taill√©
    Output->>User: Cartons optimis√©s + rapport
```

---

## ‚öñÔ∏è **Gestion des Cas Particuliers**

### **Cas 1: Articles Volumineux (Centrales, Cam√©ras)**

```mermaid
flowchart TD
    BIG_ITEM[üì¶ Article Volumineux<br/>Ex: Centrale 3kg] --> CHECK_SPACE[üîç V√©rifier Espace<br/>Cartons Existants]
    
    CHECK_SPACE --> SPACE_OK{Espace<br/>Suffisant?}
    
    SPACE_OK -->|OUI| ADD_EXISTING[‚úÖ Ajouter au<br/>Carton Existant]
    SPACE_OK -->|NON| NEW_CARTON[üì¶ Nouveau Carton<br/>D√©di√©]
    
    ADD_EXISTING --> OPTIMIZE[üéØ Compl√©ter par<br/>Petits Articles]
    NEW_CARTON --> OPTIMIZE
    
    OPTIMIZE --> VALIDATE[‚úÖ Validation Finale<br/>Contraintes Types]
    
    style BIG_ITEM fill:#ffab91
    style NEW_CARTON fill:#fff3e0
    style OPTIMIZE fill:#e1f5fe
```

### **Cas 2: Uniquement Articles Urgents B**

```mermaid
flowchart TD
    ONLY_URG_B[üü° Uniquement<br/>Urgents B] --> CREATE_BASE[üì¶ Cr√©er Cartons<br/>Base Urgents B]
    
    CREATE_BASE --> REMAINING_SPACE[üìè Calculer Espace<br/>Restant]
    
    REMAINING_SPACE --> FIND_CANDIDATES[üîç Identifier Candidats<br/>Stock < (Min+Max)/2]
    
    FIND_CANDIDATES --> PRIORITIZE[üìä Calculer Scores<br/>Priorisation]
    
    PRIORITIZE --> SELECT_BEST[üèÜ S√©lectionner<br/>Meilleurs Candidats]
    
    SELECT_BEST --> FILL_OPTIMAL[üì¶ Remplir jusqu'√†<br/>Capacit√© Optimale]
    
    FILL_OPTIMAL --> TARGET_STOCK[üéØ Ajuster Stocks vers<br/>(Min+Max)/2]
    
    style ONLY_URG_B fill:#fff3e0
    style PRIORITIZE fill:#e1f5fe
    style TARGET_STOCK fill:#c8e6c9
```

---

## üìä **M√©triques et Optimisation**

### **Indicateurs de Performance**

```mermaid
graph TB
    subgraph "M√©triques Cartons"
        M1[üìà Taux Remplissage Moyen<br/>Objectif: >85%]
        M2[üì¶ Nombre Cartons<br/>Objectif: Minimiser]
        M3[‚öñÔ∏è Respect Contraintes<br/>Objectif: 100%]
    end
    
    subgraph "M√©triques M√©tier"
        M4[üéØ Articles Critiques Trait√©s<br/>Objectif: 100%]
        M5[‚ö° Temps Traitement<br/>Objectif: <30s]
        M6[üí∞ Optimisation Co√ªt<br/>Valeur vs Transport]
    end
    
    subgraph "M√©triques Qualit√©"
        M7[üîÑ R√©utilisation Cartons<br/>Taux Compl√©tion]
        M8[üé≤ Diversit√© Articles<br/>par Carton]
        M9[üìã Satisfaction Contraintes<br/>par Type]
    end
    
    style M1 fill:#c8e6c9
    style M4 fill:#ffab91
    style M7 fill:#e1f5fe
```

### **Algorithme d'√âvaluation de Performance**

```
FONCTION EvaluerPerformance(cartons_generes, articles_origine)
D√âBUT
    // M√©triques de base
    nb_cartons ‚Üê cartons_generes.taille
    taux_remplissage_moyen ‚Üê CalculerTauxRemplissageMoyen(cartons_generes)
    
    // Respect des priorit√©s
    articles_critiques_trait√©s ‚Üê CompterArticlesCritiques(cartons_generes)
    pourcentage_critiques ‚Üê articles_critiques_trait√©s / total_critiques √ó 100
    
    // Optimisation nombre d'articles
    articles_utilises ‚Üê SommeArticles(cartons_generes)
    articles_optimal_theorique ‚Üê ArticlesMinimalTheorique(articles_origine)
    efficacite_articles ‚Üê articles_optimal_theorique / articles_utilises √ó 100
    
    // Score global
    score_performance ‚Üê 
        pourcentage_critiques √ó 0.4 +
        taux_remplissage_moyen √ó 0.3 +
        efficacite_articles √ó 0.2 +
        (100 - nb_cartons_surplus) √ó 0.1
    
    RETOURNER {
        score: score_performance,
        nb_cartons: nb_cartons,
        taux_remplissage: taux_remplissage_moyen,
        critiques_ok: pourcentage_critiques,
        efficacite_articles: efficacite_articles
    }
FIN
```

---

## üîß **Configuration et Param√©trage**

### **Param√®tres Configurables**

```json
{
  "knapsack_config": {
    "contraintes_globales": {
      "pas_limite_poids_volume": true
    },
    "contraintes_par_type": {
      "centrales": {"max_par_carton": 10},
      "claviers": {"max_par_carton": 15},
      "detecteurs": {"max_par_carton": 50},
      "cameras": {"max_par_carton": 8},
      "cables": {"max_par_carton": 100}
    },
    "priorites_completion": {
      "coefficient_ratio_stock": 0.4,
      "coefficient_tendance_usage": 0.3,
      "coefficient_densite_valeur": 0.2,
      "coefficient_criticite": 0.1,
      "seuil_selection_prioritaire": 0.6
    },
    "objectifs_performance": {
      "taux_remplissage_min": 0.75,
      "taux_remplissage_cible": 0.85,
      "temps_calcul_max_secondes": 30
    }
  }
}
```

---

## üöÄ **Algorithmes D√©taill√©s de Support**

### **Fonction: Calculer Cartons N√©cessaires**

```
FONCTION CalculerCartonsNecessaires(article)
D√âBUT
    quantite_totale ‚Üê article.quantite_besoin
    max_par_carton ‚Üê article.type.max_par_carton
    
    // Contrainte par nombre d'articles seulement
    cartons_necessaires ‚Üê PLAFOND(quantite_totale / max_par_carton)
    
    RETOURNER cartons_necessaires
FIN
```

### **Fonction: Trouver Carton Compatible**

```
FONCTION TrouverCartonCompatible(cartons_existants, article)
D√âBUT
    meilleur_carton ‚Üê null
    meilleur_score_remplissage ‚Üê 0
    
    POUR CHAQUE carton DANS cartons_existants FAIRE
        SI carton.peutAjouter(article) ALORS
            score_remplissage ‚Üê carton.calculerTauxRemplissageApresAjout(article)
            
            // Privil√©gier les cartons avec meilleur taux de remplissage
            SI score_remplissage > meilleur_score_remplissage ALORS
                meilleur_carton ‚Üê carton
                meilleur_score_remplissage ‚Üê score_remplissage
            FIN SI
        FIN SI
    FIN POUR
    
    RETOURNER meilleur_carton
FIN
```

### **Fonction: Identifier Articles Compl√©mentaires**

```
FONCTION IdentifierArticlesComplementaires()
D√âBUT
    articles_candidats ‚Üê []
    tous_articles ‚Üê GetTousArticlesStock()
    
    POUR CHAQUE article DANS tous_articles FAIRE
        stock_actuel ‚Üê article.stock_actuel
        stock_min ‚Üê article.stock_minimum  
        stock_max ‚Üê article.stock_maximum
        stock_optimal ‚Üê (stock_min + stock_max) / 2
        
        // S√©lectionner articles en-dessous du stock optimal
        SI stock_actuel < stock_optimal ALORS
            quantite_complementaire ‚Üê stock_optimal - stock_actuel
            score_priorite ‚Üê CalculerScorePriorite(article)
            
            articles_candidats.ajouter({
                article: article,
                quantite: quantite_complementaire,
                score: score_priorite
            })
        FIN SI
    FIN POUR
    
    // Trier par score d√©croissant
    TRIER articles_candidats PAR score DESCENDANT
    
    RETOURNER articles_candidats
FIN
```

### **Fonction: Compl√©ter Par Priorisation**

```
FONCTION CompleterParPriorisation(carton, articles_complementaires)
D√âBUT
    POUR CHAQUE article_candidat DANS articles_complementaires FAIRE
        quantite_max_possible ‚Üê carton.calculerQuantiteMaxPossible(article_candidat.article)
        
        SI quantite_max_possible > 0 ALORS
            quantite_a_ajouter ‚Üê MIN(article_candidat.quantite, quantite_max_possible)
            
            SI carton.peutAjouter(article_candidat.article, quantite_a_ajouter) ALORS
                carton.ajouterArticle(article_candidat.article, quantite_a_ajouter)
                
                // Mettre √† jour la quantit√© restante
                article_candidat.quantite ‚Üê article_candidat.quantite - quantite_a_ajouter
                
                // Arr√™ter si carton plein
                SI carton.estPlein() ALORS
                    SORTIR
                FIN SI
            FIN SI
        FIN SI
    FIN POUR
FIN
```

---

## üé™ **Exemples d'Ex√©cution**

### **Exemple 1: Articles Mixtes**

```
DONN√âES ENTR√âE:
- 5 Centrales CRITIQUES A
- 20 D√©tecteurs URGENTS B 
- 3 Cam√©ras SAFE

EX√âCUTION:
Phase 1: Centrales ‚Üí 1 carton d√©di√© (5 centrales max 10/carton)
Phase 2: D√©tecteurs ‚Üí Compl√©ter carton centrales (20 d√©tecteurs max 50/carton)
Phase 2: Cam√©ras ‚Üí Compl√©ter si possible (3 cam√©ras max 8/carton)

R√âSULTAT:
Carton 1: 5 centrales + 20 d√©tecteurs + 3 cam√©ras ‚úÖ
```

### **Exemple 2: Uniquement Urgents B**

```
DONN√âES ENTR√âE:
- 30 Claviers URGENTS B

EX√âCUTION:
Phase 2: Cr√©er cartons urgents B ‚Üí 2 cartons (15 claviers/carton max)
Phase 3: Compl√©ter par articles prioritaires

Articles compl√©mentaires identifi√©s:
- C√¢bles RJ45: stock=10, optimal=25 ‚Üí +15 c√¢bles
- D√©tecteurs: stock=30, optimal=45 ‚Üí +15 d√©tecteurs

R√âSULTAT:
Carton 1: 15 claviers + 50 c√¢bles + 15 d√©tecteurs ‚úÖ
Carton 2: 15 claviers + compl√©ments ‚úÖ
```

---

## üîç **Optimisations Avanc√©es**

### **Optimisation G√©n√©tique pour Cas Complexes**

```
ALGORITHME OptimisationGenetique(articles, nb_generations = 100)
D√âBUT
    population ‚Üê GenererPopulationInitiale(articles, taille = 50)
    
    POUR generation ‚Üê 1 A nb_generations FAIRE
        // √âvaluation fitness
        POUR CHAQUE individu DANS population FAIRE
            individu.fitness ‚Üê EvaluerSolution(individu)
        FIN POUR
        
        // S√©lection des parents
        parents ‚Üê SelectionTournoi(population, taux = 0.7)
        
        // Croisement et mutation
        enfants ‚Üê []
        POUR i ‚Üê 1 A taille_population / 2 FAIRE
            parent1, parent2 ‚Üê ChoisirParents(parents)
            enfant1, enfant2 ‚Üê Croisement(parent1, parent2)
            Mutation(enfant1, taux = 0.1)
            Mutation(enfant2, taux = 0.1)
            enfants.ajouter(enfant1, enfant2)
        FIN POUR
        
        // Remplacement √©litiste
        population ‚Üê RemplacementElitiste(population, enfants)
    FIN POUR
    
    RETOURNER MeilleurIndividu(population)
FIN
```

Cette approche **Knapsack modifi√©e** garantit le traitement prioritaire des articles critiques tout en optimisant l'utilisation de l'espace disponible et en permettant une compl√©tion intelligente bas√©e sur la priorit√© m√©tier.
